(function(){"use strict";const t={DATA_TYPE_DOUBLE:{ordinal:0,name:"double",size:8},DATA_TYPE_FLOAT:{ordinal:1,name:"float",size:4},DATA_TYPE_INT8:{ordinal:2,name:"int8",size:1},DATA_TYPE_UINT8:{ordinal:3,name:"uint8",size:1},DATA_TYPE_INT16:{ordinal:4,name:"int16",size:2},DATA_TYPE_UINT16:{ordinal:5,name:"uint16",size:2},DATA_TYPE_INT32:{ordinal:6,name:"int32",size:4},DATA_TYPE_UINT32:{ordinal:7,name:"uint32",size:4},DATA_TYPE_INT64:{ordinal:8,name:"int64",size:8},DATA_TYPE_UINT64:{ordinal:9,name:"uint64",size:8}};let g=0;for(let O in t)t[g]=t[O],g++;class i{constructor(b,y,D,Y=[1/0,-1/0]){this.name=b,this.type=y,this.numElements=D,this.range=Y,this.byteSize=this.numElements*this.type.size,this.description=""}}new i("POSITION_CARTESIAN",t.DATA_TYPE_FLOAT,3),new i("COLOR_PACKED",t.DATA_TYPE_INT8,4),new i("COLOR_PACKED",t.DATA_TYPE_INT8,4),new i("COLOR_PACKED",t.DATA_TYPE_INT8,3),new i("NORMAL_FLOATS",t.DATA_TYPE_FLOAT,3),new i("INTENSITY",t.DATA_TYPE_UINT16,1),new i("CLASSIFICATION",t.DATA_TYPE_UINT8,1),new i("NORMAL_SPHEREMAPPED",t.DATA_TYPE_UINT8,2),new i("NORMAL_OCT16",t.DATA_TYPE_UINT8,2),new i("NORMAL",t.DATA_TYPE_FLOAT,3),new i("RETURN_NUMBER",t.DATA_TYPE_UINT8,1),new i("NUMBER_OF_RETURNS",t.DATA_TYPE_UINT8,1),new i("SOURCE_ID",t.DATA_TYPE_UINT16,1),new i("INDICES",t.DATA_TYPE_UINT32,1),new i("SPACING",t.DATA_TYPE_FLOAT,1),new i("GPS_TIME",t.DATA_TYPE_DOUBLE,1);const M={int8:Int8Array,int16:Int16Array,int32:Int32Array,int64:Float64Array,uint8:Uint8Array,uint16:Uint16Array,uint32:Uint32Array,uint64:Float64Array,float:Float32Array,double:Float64Array};onmessage=function(O){let{buffer:b,pointAttributes:y,scale:D,name:Y,min:U,max:G,size:p,offset:R,numPoints:s}=O.data;performance.now();let A=new DataView(b),E={},I=0,m=0;for(let e of y.attributes)m+=e.byteSize;let _=32,z=new Uint32Array(_**3),F=(e,T,r)=>{let n=_*e/p.x,a=_*T/p.y,l=_*r/p.z,f=Math.min(parseInt(n),_-1),u=Math.min(parseInt(a),_-1),N=Math.min(parseInt(l),_-1);return f+u*_+N*_*_},C=0;for(let e of y.attributes){if(["POSITION_CARTESIAN","position"].includes(e.name)){let T=new ArrayBuffer(s*4*3),r=new Float32Array(T);for(let n=0;n<s;n++){let a=n*m,l=A.getInt32(a+I+0,!0)*D[0]+R[0]-U.x,f=A.getInt32(a+I+4,!0)*D[1]+R[1]-U.y,u=A.getInt32(a+I+8,!0)*D[2]+R[2]-U.z,N=F(l,f,u);z[N]++===0&&C++,r[3*n+0]=l,r[3*n+1]=f,r[3*n+2]=u}E[e.name]={buffer:T,attribute:e}}else if(["RGBA","rgba"].includes(e.name)){let T=new ArrayBuffer(s*4),r=new Uint8Array(T);for(let n=0;n<s;n++){let a=n*m,l=A.getUint16(a+I+0,!0),f=A.getUint16(a+I+2,!0),u=A.getUint16(a+I+4,!0);r[4*n+0]=l>255?l/256:l,r[4*n+1]=f>255?f/256:f,r[4*n+2]=u>255?u/256:u}E[e.name]={buffer:T,attribute:e}}else{let T=new ArrayBuffer(s*4),r=new Float32Array(T),n=M[e.type.name],a=new n(s),[l,f]=[0,1];const N={int8:A.getInt8,int16:A.getInt16,int32:A.getInt32,uint8:A.getUint8,uint16:A.getUint16,uint32:A.getUint32,float:A.getFloat32,double:A.getFloat64}[e.type.name].bind(A);if(e.type.size>4){let[o,P]=e.range;l=o,f=1/(P-o)}for(let o=0;o<s;o++){let P=o*m,c=N(P+I,!0);r[o]=(c-l)*f,a[o]=c}E[e.name]={buffer:T,preciseBuffer:a,attribute:e,offset:l,scale:f}}I+=e.byteSize}let B=parseInt(s/C);{let e=new ArrayBuffer(s*4),T=new Uint32Array(e);for(let r=0;r<s;r++)T[r]=r;E.INDICES={buffer:e,attribute:i.INDICES}}{let e=y.vectors;for(let T of e){let{name:r,attributes:n}=T,a=n.length,l=new ArrayBuffer(a*s*4),f=new Float32Array(l),u=0;for(let o of n){let P=E[o],{offset:c,scale:h}=P,L=new DataView(P.buffer);const x=L.getFloat32.bind(L);for(let w=0;w<s;w++){let v=x(w*4,!0);f[w*a+u]=v/h+c}u++}let N=new i(r,t.DATA_TYPE_FLOAT,3);E[r]={buffer:l,attribute:N}}}let d={buffer:b,attributeBuffers:E,density:B},S=[];for(let e in d.attributeBuffers)S.push(d.attributeBuffers[e].buffer);S.push(b),postMessage(d,S)}})();
