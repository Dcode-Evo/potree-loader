(function(){"use strict";const t={DATA_TYPE_DOUBLE:{ordinal:0,name:"double",size:8},DATA_TYPE_FLOAT:{ordinal:1,name:"float",size:4},DATA_TYPE_INT8:{ordinal:2,name:"int8",size:1},DATA_TYPE_UINT8:{ordinal:3,name:"uint8",size:1},DATA_TYPE_INT16:{ordinal:4,name:"int16",size:2},DATA_TYPE_UINT16:{ordinal:5,name:"uint16",size:2},DATA_TYPE_INT32:{ordinal:6,name:"int32",size:4},DATA_TYPE_UINT32:{ordinal:7,name:"uint32",size:4},DATA_TYPE_INT64:{ordinal:8,name:"int64",size:8},DATA_TYPE_UINT64:{ordinal:9,name:"uint64",size:8}};let S=0;for(let O in t)t[S]=t[O],S++;class i{constructor(P,b,y,g=[1/0,-1/0]){this.name=P,this.type=b,this.numElements=y,this.range=g,this.byteSize=this.numElements*this.type.size,this.description=""}}new i("POSITION_CARTESIAN",t.DATA_TYPE_FLOAT,3),new i("COLOR_PACKED",t.DATA_TYPE_INT8,4),new i("COLOR_PACKED",t.DATA_TYPE_INT8,4),new i("COLOR_PACKED",t.DATA_TYPE_INT8,3),new i("NORMAL_FLOATS",t.DATA_TYPE_FLOAT,3),new i("INTENSITY",t.DATA_TYPE_UINT16,1),new i("CLASSIFICATION",t.DATA_TYPE_UINT8,1),new i("NORMAL_SPHEREMAPPED",t.DATA_TYPE_UINT8,2),new i("NORMAL_OCT16",t.DATA_TYPE_UINT8,2),new i("NORMAL",t.DATA_TYPE_FLOAT,3),new i("RETURN_NUMBER",t.DATA_TYPE_UINT8,1),new i("NUMBER_OF_RETURNS",t.DATA_TYPE_UINT8,1),new i("SOURCE_ID",t.DATA_TYPE_UINT16,1),new i("INDICES",t.DATA_TYPE_UINT32,1),new i("SPACING",t.DATA_TYPE_FLOAT,1),new i("GPS_TIME",t.DATA_TYPE_DOUBLE,1);const L={int8:Int8Array,int16:Int16Array,int32:Int32Array,int64:Float64Array,uint8:Uint8Array,uint16:Uint16Array,uint32:Uint32Array,uint64:Float64Array,float:Float32Array,double:Float64Array};Potree={},onmessage=function(O){let{buffer:P,pointAttributes:b,scale:y,name:g,min:p,max:G,size:w,offset:U,numPoints:u}=O.data;performance.now();let a=new DataView(P),E={},I=0,m=0;for(let e of b.attributes)m+=e.byteSize;let _=32,B=new Uint32Array(_**3),M=(e,T,r)=>{let n=_*e/w.x,A=_*T/w.y,l=_*r/w.z,o=Math.min(parseInt(n),_-1),s=Math.min(parseInt(A),_-1),f=Math.min(parseInt(l),_-1);return o+s*_+f*_*_},Y=0;for(let e of b.attributes){if(["POSITION_CARTESIAN","position"].includes(e.name)){let T=new ArrayBuffer(u*4*3),r=new Float32Array(T);for(let n=0;n<u;n++){let A=n*m,l=a.getInt32(A+I+0,!0)*y[0]+U[0]-p.x,o=a.getInt32(A+I+4,!0)*y[1]+U[1]-p.y,s=a.getInt32(A+I+8,!0)*y[2]+U[2]-p.z,f=M(l,o,s);B[f]++===0&&Y++,r[3*n+0]=l,r[3*n+1]=o,r[3*n+2]=s}E[e.name]={buffer:T,attribute:e}}else if(["RGBA","rgba"].includes(e.name)){let T=new ArrayBuffer(u*4),r=new Uint8Array(T);for(let n=0;n<u;n++){let A=n*m,l=a.getUint16(A+I+0,!0),o=a.getUint16(A+I+2,!0),s=a.getUint16(A+I+4,!0);r[4*n+0]=l>255?l/256:l,r[4*n+1]=o>255?o/256:o,r[4*n+2]=s>255?s/256:s}E[e.name]={buffer:T,attribute:e}}else{let T=new ArrayBuffer(u*4),r=new Float32Array(T),n=L[e.type.name];preciseBuffer=new n(u);let[A,l]=[0,1];const s={int8:a.getInt8,int16:a.getInt16,int32:a.getInt32,uint8:a.getUint8,uint16:a.getUint16,uint32:a.getUint32,float:a.getFloat32,double:a.getFloat64}[e.type.name].bind(a);if(e.type.size>4){let[f,N]=e.range;A=f,l=1/(N-f)}for(let f=0;f<u;f++){let N=f*m,D=s(N+I,!0);r[f]=(D-A)*l,preciseBuffer[f]=D}E[e.name]={buffer:T,preciseBuffer,attribute:e,offset:A,scale:l}}I+=e.byteSize}let z=parseInt(u/Y);{let e=new ArrayBuffer(u*4),T=new Uint32Array(e);for(let r=0;r<u;r++)T[r]=r;E.INDICES={buffer:e,attribute:i.INDICES}}{let e=b.vectors;for(let T of e){let{name:r,attributes:n}=T,A=n.length,l=new ArrayBuffer(A*u*4),o=new Float32Array(l),s=0;for(let N of n){let D=E[N],{offset:F,scale:h}=D,C=new DataView(D.buffer);const x=C.getFloat32.bind(C);for(let c=0;c<u;c++){let v=x(c*4,!0);o[c*A+s]=v/h+F}s++}let f=new i(r,t.DATA_TYPE_FLOAT,3);E[r]={buffer:l,attribute:f}}}let R={buffer:P,attributeBuffers:E,density:z},d=[];for(let e in R.attributeBuffers)d.push(R.attributeBuffers[e].buffer);d.push(P),postMessage(R,d)}})();
